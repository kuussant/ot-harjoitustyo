import pygame
import random
from collections import deque

import utils.editor_utils as eu
import statics as s
import sound

from sprites.defender import Defender
from sprites.enemy import Enemy
from sprites.map import Map
from defender_data import DEFENDER_DATA


class Stage:
    """The stage class, where the game logic takes place.

    Attributes:
        money: The amount of money the player has.
        assets: All of the game assets: images, sounds.
        map: The game map object.
        path_nodes: The path nodes enemies follow generated byt the map.
        waves: A spawn data dictionary that contains enemies and spawn rate.
        spawn_list: An empty spawn list that will contain the current wave of enemies as enemy types.
        wave_started: A boolean value that dictates if a wave has started.
        stage_won: A boolean value that dictates if the stage has been completed.
        play_area: A 2D array where Defenders are stored during gameplay.
        all_sprites: Sprite group for all of the sprites.
        defender_group: Sprite group for defenders
        enemy_group: Sprite group for enemies
        bullet_group: Sprite group for bullets
        tile_group: Sprite group for map tiles
    """
    def __init__(self, assets, map_file, spawn_data):
        """The stage constructor, where the stage is created.

        Args:
            map_file: A json-file containing map data.
            spawn_data: A dictionary containing enemy spawning data.
        """
        self.money = 50
        self.assets = assets
        self.map = Map(self.assets, eu.load_map(
            map_file), (s.TILE_SIZE, s.TILE_SIZE))
        self.path_nodes = self.map.get_path()

        self.waves = spawn_data
        self.wave = 0
        self.spawn_list = deque([])
        self.wave_started = False
        self.stage_won = False

        self.play_area = [[None]*len(self.map.get_map()[0])
                          for _ in range(len(self.map.get_map()))]

        self.all_sprites = pygame.sprite.Group()
        self.defender_group = pygame.sprite.Group()
        self.enemy_group = pygame.sprite.Group()
        self.bullet_group = pygame.sprite.Group()
        self.tile_group = pygame.sprite.Group()

        self.tile_group = self.map.load_map()
        self.all_sprites.add(self.tile_group)

    def _spawn_enemy(self, enemy_type):
        """A private method for spawning an enemy.

        Args:
            enemy_type: The type of the enemy who is spawned.
        """
        new_enemy = Enemy(self.assets, enemy_type, self.path_nodes)
        self.enemy_group.add(new_enemy)
        self.all_sprites.add(new_enemy)

    def handle_wave(self):
        """Handles the enemy spawns that generate_spawns generated (a list of enemy types), and
        spawns enemies with _spawn_enemy method when the spawn_list is empty and stage_won is false.

        Called in Game-class.

        Returns:
            True, if wave is clear, otherwise False.
        """
        if self.spawn_list and not self.stage_won:
            next_spawn_type = self.spawn_list.popleft()
            self._spawn_enemy(next_spawn_type)
        elif not self.enemy_group:
            self.wave_started = False

            if self.wave >= len(self.waves) - 1:
                self.stage_won = True
            else:
                self.wave += 1
                print("wave cleared")
            return False
        return True

    def generate_spawns(self):
        """Generate spawns from wave_data.

            Creates a list of enemy types and shuffles it, and sets wave_started as True.

            Called in the Game-class
        """
        if not self.enemy_group:
            self.spawn_list = deque([])
            for key, val in self.waves[self.wave]["enemies"].items():
                self.spawn_list += [key for _ in range(0, val)]

            random.shuffle(self.spawn_list)
            self.wave_started = True

    def get_wave_spawn_rate(self):
        """Gets the spawnrate of the current wave.

        Returns:
            The spawnrate, that is an interval at which enemies spawn in milliseconds.
        """
        return self.waves[self.wave]["spawn_rate"]

    def wave_has_started(self):
        """Checks if a wave has started.

        Returns:
            True, if wave has started, otherwise False.
        """
        return self.wave_started

    def game_won(self):
        """Checks if stage is won.

        Returns:
            True, if stage is won, otherwise False.
        """
        return self.stage_won

    # Needs defender type
    def add_defender(self, defender_type, pos):
        """Adds a defender on the map.

        Args:
            pos: The coordinate position of the defender that gets converted into map index, and then
            the center of the corresponding tile.
        
        """
        tile_index = self.get_free_tile_index_by_pos(pos)

        if tile_index:
            defender = self.play_area[tile_index[0]][tile_index[1]]
            if defender is None:
                if self.money >= DEFENDER_DATA[defender_type]["cost"]:
                    tile_center = eu.get_tile_center_by_index(
                        tile_index, self.map.get_pos())

                    new_defender = Defender(self.assets, defender_type, tile_center)
                    self.play_area[tile_index[0]][tile_index[1]] = new_defender
                    self.defender_group.add(new_defender)
                    self.all_sprites.add(new_defender)
                    self.money -= DEFENDER_DATA[defender_type]["cost"]
                    sound.play(self.assets[1]["coin_sound2"], 0.3)
                    
                    return True

        return False

    def check_defender(self, pos):
        """Checks if a defender is on a tile.

        Args:
            pos: The position within a tile that is checked.
        
        Returns:
            None if there's no defender in the position or the defender if there is one.
        """
        tile_index = self.get_free_tile_index_by_pos(pos)

        if tile_index:
            defender = self.play_area[tile_index[0]][tile_index[1]]

            if defender is not None:
                pass

        return None

    def update(self):
        """Updates all of the elements on the stage.
    
        """
        if not self.stage_won:
            self.enemy_group.update()
            self.bullet_group.update()
            self.defender_group.update(
                self.enemy_group, self.bullet_group, self.all_sprites)
            self._enemy_and_bullet_collision()

    def draw(self, display):
        """Draws the elements on the display.

        Args:
            display: Pygame display where the stage elements are drawn.
        """
        self.all_sprites.draw(display)
        self.tile_group.update(display)

    def get_free_tile_index_by_pos(self, pos):
        """Gets the index of a tile where you can place a defender.

        Args:
            pos: The display coordinate position within the placeable tile index.

        Returns:
            None if there is no valid tile for a placable defender or tile_index if the tile is valid.
        """
        tile_index = eu.get_map_tile_by_mouse_coord(
            self.map.get_map(), pos, self.map.get_pos())

        if tile_index is not None:
            tile_id = self.map.get_map()[tile_index[0]][tile_index[1]]

            if eu.get_tile_type(tile_id) == s.FREE_TILE:
                return tile_index

            else:
                return None
        else:
            return None

    def _enemy_and_bullet_collision(self):
        """Checks the collision between enemies and bullets.

        """
        if pygame.sprite.groupcollide(self.enemy_group, self.bullet_group, False, False):
            collide_group = pygame.sprite.groupcollide(self.enemy_group, self.bullet_group, False, True, pygame.sprite.collide_mask)
            for enemy, bullets in collide_group.items():
                enemy_dead = False
                for bullet in bullets:
                    money_accumulated = enemy.deal_damage(bullet.damage)
                    if money_accumulated > 0 and not enemy_dead:
                        self.money += money_accumulated
                        sound.play(self.assets[1]["coin_sound3"], 0.4)
                        enemy_dead = True
